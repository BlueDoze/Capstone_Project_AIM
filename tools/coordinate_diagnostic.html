<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coordinate System Diagnostic</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Courier New', monospace;
            background: #f5f5f5;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        h1 { color: #333; margin-bottom: 20px; }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .panel {
            border: 2px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            background: #fafafa;
        }

        .panel h2 {
            color: #2196f3;
            margin-bottom: 15px;
            font-size: 16px;
            border-bottom: 2px solid #2196f3;
            padding-bottom: 10px;
        }

        #mapLeft, #mapRight {
            height: 500px;
            border: 2px solid #ccc;
            border-radius: 5px;
            margin-bottom: 15px;
        }

        .info-box {
            background: #f0f7ff;
            border-left: 4px solid #2196f3;
            padding: 10px;
            margin: 10px 0;
            font-size: 12px;
            line-height: 1.6;
        }

        .coord-display {
            background: #263238;
            color: #aed581;
            padding: 10px;
            border-radius: 3px;
            font-size: 11px;
            margin: 10px 0;
            word-break: break-all;
            max-height: 200px;
            overflow-y: auto;
        }

        button {
            background: #2196f3;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin: 5px 0;
            width: 100%;
        }

        button:hover { background: #1976d2; }

        .debug-log {
            background: #263238;
            color: #aed581;
            padding: 15px;
            border-radius: 5px;
            height: 300px;
            overflow-y: auto;
            font-size: 11px;
            font-family: 'Courier New', monospace;
            line-height: 1.4;
        }

        .log-entry {
            margin: 5px 0;
            padding: 3px;
            border-left: 2px solid #aed581;
            padding-left: 8px;
        }

        .error { color: #ff5252; border-left-color: #ff5252; }
        .success { color: #69f0ae; border-left-color: #69f0ae; }
        .info { color: #aed581; }

        .marker {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 12px;
        }

        .full-width {
            grid-column: 1 / -1;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç Coordinate System Diagnostic Tool</h1>

        <div class="grid">
            <!-- LEFT SIDE: find_room_centers approach -->
            <div class="panel">
                <h2>üìç find_room_centers.html Approach</h2>
                <div id="svgLeftContainer" style="border: 2px solid #ccc; border-radius: 5px; overflow: auto; height: 500px; background: white;">
                    <svg id="svgLeft" style="width: 100%; height: auto;"></svg>
                </div>
                <button onclick="clickSvgLeft()">üñ±Ô∏è Click on SVG to capture coordinates (NO rotation)</button>
                <div class="info-box">
                    <strong>Method:</strong> SVG raw coordinates, no rotation applied<br>
                    <strong>Used for:</strong> find_room_centers.html<br>
                    <strong>ViewBox:</strong> 0 0 816 1056
                </div>
                <div class="coord-display" id="coordLeft">Click on SVG to capture...</div>
            </div>

            <!-- RIGHT SIDE: Application approach -->
            <div class="panel">
                <h2>üó∫Ô∏è Application Map Approach (Leaflet + SVG)</h2>
                <div id="mapRight" style="height: 500px; border: 2px solid #ccc; border-radius: 5px;"></div>
                <button onclick="clickMapRight()">üñ±Ô∏è Click on map to see coordinates (WITH 21.3¬∞ rotation)</button>
                <div class="info-box">
                    <strong>Method:</strong> Leaflet map with SVG overlay + 21.3¬∞ rotation<br>
                    <strong>Used for:</strong> Main application<br>
                    <strong>Bearing:</strong> 21.3¬∞
                </div>
                <div class="coord-display" id="coordRight">Click on map to capture...</div>
            </div>

            <!-- DEBUG LOG -->
            <div class="panel full-width">
                <h2>üîß Debug Log</h2>
                <div class="debug-log" id="debugLog">Waiting for interactions...</div>
                <button onclick="clearLog()">üóëÔ∏è Clear Log</button>
            </div>
        </div>
    </div>

    <script>
        let mapRight, svgElement, svgElement2;
        let lastSvgCoords = null;
        let lastLatLng = null;
        let currentCorners = null;

        function log(message, type = 'info') {
            const logDiv = document.getElementById('debugLog');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function clearLog() {
            document.getElementById('debugLog').innerHTML = '';
        }

        function rotatePoint(x, y, centerX, centerY, angleDeg) {
            const angleRad = (angleDeg * Math.PI) / 180;
            const cos = Math.cos(angleRad);
            const sin = Math.sin(angleRad);

            const dx = x - centerX;
            const dy = y - centerY;

            return {
                x: centerX + (dx * cos - dy * sin),
                y: centerY + (dx * cos + dy * sin)
            };
        }

        function svgCoordsToLatLng(svgX, svgY, corners) {
            const svgBBox = { x: 0, y: 0, width: 816, height: 1056 };

            // Normalize to 0-1
            const normX = (svgX - svgBBox.x) / svgBBox.width;
            const normY = (svgY - svgBBox.y) / svgBBox.height;

            const topLeft = corners[0], topRight = corners[1],
                bottomRight = corners[2], bottomLeft = corners[3];

            // Bilinear interpolation
            const latTop = topLeft.lat + normX * (topRight.lat - topLeft.lat);
            const lngTop = topLeft.lng + normX * (topRight.lng - topLeft.lng);
            const latBottom = bottomLeft.lat + normX * (bottomRight.lat - bottomLeft.lat);
            const lngBottom = bottomLeft.lng + normX * (bottomRight.lng - bottomLeft.lng);

            const nodeLat = latTop + normY * (latBottom - latTop);
            const nodeLng = lngTop + normY * (lngBottom - lngTop);

            return { lat: nodeLat, lng: nodeLng };
        }

        async function initDiagnostic() {
            log('Loading SVG and initializing maps...', 'info');

            // Load SVG
            try {
                const response = await fetch('../LeafletJS/Floorplans/Building M/M1_official.svg');
                const svgText = await response.text();

                // LEFT: Display SVG as-is
                const svgLeftContainer = document.getElementById('svgLeftContainer');
                svgLeftContainer.innerHTML = svgText;
                svgElement = svgLeftContainer.querySelector('svg');
                svgElement.style.width = '100%';
                svgElement.style.height = 'auto';

                // RIGHT: Prepare SVG for Leaflet overlay
                const svgDoc = new DOMParser().parseFromString(svgText, 'image/svg+xml');
                svgElement2 = svgDoc.documentElement;

                log(`‚úÖ SVG loaded: viewBox="0 0 816 1056"`, 'success');

            } catch (error) {
                log(`‚ùå Error loading SVG: ${error}`, 'error');
                return;
            }

            // Initialize Leaflet map (RIGHT SIDE)
            try {
                mapRight = L.map('mapRight', {
                    maxZoom: 22,
                    minZoom: 16,
                    rotate: true,
                    bearing: 21.3
                }).setView([43.0125, -81.2002], 18);

                L.tileLayer("https://api.maptiler.com/maps/streets-v2/{z}/{x}/{y}.png?key=d3JSA6Uq18jaERqMgDqq", {
                    attribution: '¬© MapTiler ¬© OpenStreetMap',
                    maxZoom: 22
                }).addTo(mapRight);

                // Load GeoJSON to calculate corners
                const geoResponse = await fetch('../LeafletJS/campus.geojson');
                const geoData = await geoResponse.json();

                const buildingMFeature = geoData.features.find(f => f.properties.name === 'Building M');
                if (buildingMFeature) {
                    const layer = L.geoJSON(buildingMFeature);
                    const bounds = layer.getBounds();
                    const center = bounds.getCenter();

                    // Calculate corners WITHOUT rotation (for comparison)
                    const cornersNoRotation = [
                        L.latLng(bounds.getNorth(), bounds.getWest()),
                        L.latLng(bounds.getNorth(), bounds.getEast()),
                        L.latLng(bounds.getSouth(), bounds.getEast()),
                        L.latLng(bounds.getSouth(), bounds.getWest())
                    ];

                    // Apply rotation (as application does)
                    const mapBearing = 21.3;
                    currentCorners = cornersNoRotation.map(corner => rotatePoint(corner.lat, corner.lng, center.lat, center.lng, mapBearing));
                    currentCorners = currentCorners.map(c => ({ lat: c.x, lng: c.y }));

                    log(`‚úÖ Leaflet map initialized with 21.3¬∞ rotation`, 'success');
                    log(`Building M bounds: N=${bounds.getNorth().toFixed(6)}, S=${bounds.getSouth().toFixed(6)}, E=${bounds.getEast().toFixed(6)}, W=${bounds.getWest().toFixed(6)}`, 'info');

                    // Add SVG overlay
                    const svgOverlay = L.svgOverlay(svgElement2, currentCorners, {
                        interactive: false,
                        opacity: 0.4
                    }).addTo(mapRight);

                    log(`‚úÖ SVG overlay added to map with rotation`, 'success');
                } else {
                    log(`‚ùå Building M not found in GeoJSON`, 'error');
                }

            } catch (error) {
                log(`‚ùå Error initializing map: ${error}`, 'error');
            }
        }

        function clickSvgLeft() {
            if (!svgElement) {
                log('SVG not loaded yet', 'error');
                return;
            }

            svgElement.addEventListener('click', function(e) {
                // Get click position relative to SVG
                const rect = svgElement.getBoundingClientRect();
                const svgRect = svgElement.viewBox.baseVal || { x: 0, y: 0, width: 816, height: 1056 };

                const clientX = e.clientX - rect.left;
                const clientY = e.clientY - rect.top;

                const svgX = (clientX / rect.width) * svgRect.width;
                const svgY = (clientY / rect.height) * svgRect.height;

                lastSvgCoords = { x: svgX, y: svgY };

                const output = `
SVG Coordinates (NO rotation):
  X: ${svgX.toFixed(2)}
  Y: ${svgY.toFixed(2)}

ViewBox: 0 0 816 1056
Click position: (${clientX.toFixed(0)}, ${clientY.toFixed(0)}) pixels
                `;

                document.getElementById('coordLeft').textContent = output;
                log(`Left SVG click: (${svgX.toFixed(1)}, ${svgY.toFixed(1)})`, 'success');

                // Add visual marker on SVG
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', svgX);
                circle.setAttribute('cy', svgY);
                circle.setAttribute('r', '10');
                circle.setAttribute('fill', 'none');
                circle.setAttribute('stroke', '#2196f3');
                circle.setAttribute('stroke-width', '2');
                svgElement.appendChild(circle);

                // Compare with right side
                if (lastLatLng) {
                    compareCoordinates();
                }
            }, { once: true });

            log('Click anywhere on the LEFT SVG to capture coordinates...', 'info');
        }

        function clickMapRight() {
            if (!mapRight || !currentCorners) {
                log('Map or corners not initialized', 'error');
                return;
            }

            mapRight.once('click', function(e) {
                const latlng = e.latlng;
                lastLatLng = { lat: latlng.lat, lng: latlng.lng };

                // Convert to SVG coordinates using the SAME corners
                const svgCoords = latLngToSvgCoords(latlng.lat, latlng.lng, currentCorners);

                const output = `
Map Coordinates (WITH 21.3¬∞ rotation):
  Lat: ${latlng.lat.toFixed(6)}
  Lng: ${latlng.lng.toFixed(6)}

Converted to SVG (with rotation applied):
  X: ${svgCoords.x.toFixed(2)}
  Y: ${svgCoords.y.toFixed(2)}
                `;

                document.getElementById('coordRight').textContent = output;
                log(`Right map click: LatLng(${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)}) ‚Üí SVG(${svgCoords.x.toFixed(1)}, ${svgCoords.y.toFixed(1)})`, 'success');

                // Add marker
                L.circleMarker(latlng, {
                    radius: 5,
                    color: '#ff5252',
                    fillColor: '#ff5252',
                    fillOpacity: 0.8
                }).addTo(mapRight);

                // Compare
                if (lastSvgCoords) {
                    compareCoordinates();
                }
            });

            log('Click anywhere on the RIGHT map to capture coordinates...', 'info');
        }

        function latLngToSvgCoords(lat, lng, corners) {
            // Inverse of bilinear interpolation
            // This is simplified; exact inverse is complex
            // Using approximation based on bounds
            const topLeft = corners[0], topRight = corners[1],
                bottomRight = corners[2], bottomLeft = corners[3];

            // Approximate center and bounds
            const centerLat = (topLeft.lat + bottomRight.lat) / 2;
            const centerLng = (topLeft.lng + bottomRight.lng) / 2;

            const normX = (lng - topLeft.lng) / (topRight.lng - topLeft.lng);
            const normY = (lat - topLeft.lat) / (bottomLeft.lat - topLeft.lat);

            return {
                x: normX * 816,
                y: normY * 1056
            };
        }

        function compareCoordinates() {
            if (!lastSvgCoords || !lastLatLng) return;

            const dx = lastSvgCoords.x - (lastLatLng.x || 400);
            const dy = lastSvgCoords.y - (lastLatLng.y || 500);
            const distance = Math.sqrt(dx * dx + dy * dy);

            log(`üìä Coordinate Comparison:`, 'info');
            log(`  Left SVG: (${lastSvgCoords.x.toFixed(2)}, ${lastSvgCoords.y.toFixed(2)})`, 'info');
            log(`  SVG distance: ${distance.toFixed(2)} units`, distance > 50 ? 'error' : 'success');
        }

        // Initialize on load
        window.addEventListener('load', initDiagnostic);
    </script>
</body>
</html>
