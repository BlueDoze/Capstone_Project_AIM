<!-- cd "C:\Users\Lukeg\Desktop\Capstone Project\LeafletJS" -->
<!-- python -m http.server 8000 -->

<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Campus Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-image-transform/leaflet-image-transform.min.js"></script>
    <style>
        #map {
            position: absolute;
            top: 0; bottom: 0;
            left: 0; right: 0;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <script>
		
		//Functions 
		function openFloorPlan() {
			let select = document.getElementById("floorSelect");
			let filePath = select.value;
			window.open(filePath, "_blank"); // open in new tab
		}


		function doorToLatLng(doorElement, svgMap, corners) {
			const bbox = doorElement.getBBox();
			const doorCenterX = bbox.x + bbox.width / 2;
			const doorCenterY = bbox.y + bbox.height / 2;

			const svgBBox = svgMap.viewBox.baseVal || {
				x: 0,
				y: 0,
				width: svgMap.width.baseVal.value,
				height: svgMap.height.baseVal.value
			};

			const normX = (doorCenterX - svgBBox.x) / svgBBox.width;
			const normY = (doorCenterY - svgBBox.y) / svgBBox.height;

			const topLeft = corners[0], topRight = corners[1],
				bottomRight = corners[2], bottomLeft = corners[3];

			const latTop = topLeft.lat + normX * (topRight.lat - topLeft.lat);
			const lngTop = topLeft.lng + normX * (topRight.lng - topLeft.lng);
			const latBottom = bottomLeft.lat + normX * (bottomRight.lat - bottomLeft.lat);
			const lngBottom = bottomLeft.lng + normX * (bottomRight.lng - bottomLeft.lng);

			const doorLat = latTop + normY * (latBottom - latTop);
			const doorLng = lngTop + normY * (lngBottom - lngTop);

			return L.latLng(doorLat, doorLng);
		}


		// --- Helper: Find closest hallway node to a given point ---
		function findClosestNode(latlng, nodeList) {
			let closest = null, minDist = Infinity;
			nodeList.forEach(node => {
				const d = latlng.distanceTo(node);
				if (d < minDist) {
					minDist = d;
					closest = node;
				}
			});
			return closest;
		}

		
        // Step 1: Initialize the map
        let map = L.map('map', {
            maxZoom: 22   // allow very close zoom
        }).setView([43.0125, -81.2002], 16);



        // Step 2: Add tile layer (the actual map)
        L.tileLayer(
            "https://api.maptiler.com/maps/streets-v2/{z}/{x}/{y}.png?key=d3JSA6Uq18jaERqMgDqq",
            {
            attribution: '&copy; <a href="https://www.maptiler.com/">MapTiler</a> &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a>',
            maxZoom: 22
            }
        ).addTo(map);
		

        // Test (User starting location)

        let startPoint = L.latLng(43.0143425, -81.19856355); // Example coordinate near Building M
        let startMarker = L.marker(startPoint, {
            title: "You are here",
            draggable: false
        }).addTo(map);

        startMarker.bindPopup("<b>You are here</b>").openPopup();

		let currentOverlay = null;

		window.hallwayLatLngs = []; // store hallway nodes globally
		window.currentPathLine = null;


		//Floor plan data
		const floorPlans = {
			"Building A": {
				"path" : "Floorplans/Building A",
				"plans": ["A1.jpeg", "A2.jpeg", "A3.jpeg"]},
			"Building B": {
				"path" : "Floorplans/Building B",
				"plans": ["B1.jpeg", "B2.jpeg", "B3.jpeg"]},
			"Building C": {
				"path" : "Floorplans/Building C",
				"plans": ["C1.jpeg", "C2.jpeg", "C3.jpeg"]},
			"Building M": {
				"path" : "Floorplans/Building M",
				"plans": ["M1_test.svg", "M2.jpeg", "M3.jpeg"],
				"objects": {
					"floor1": {
						"rooms" :
						{
							"Room_1003": ["Door_1003_1", "Door_1003_2"],
							"Room_1004": ["Door_1004"], 
							"Room_1006": ["Door_1006"], 
							"Room_1013-14": ["Door_1013-14"],
							"Room_1018": ["Door_1018"],
							"Room_1030": ["Door_1030"],
							"Room_1033": ["Door_1033"],
							"Room_1035": ["Door_1035"],
							"Room_1037": ["Door_1037"],
							"Room_1040": ["Door_1040"],
							"Room_1041": ["Door_1041"],
							"Room_1041-2": ["Door_1041-2"],
							"Room_1045": ["Door_1045"]
						},
						"entrances":
						{
							"Outside-Exit_1": ["Outside"],
							"Outside-Exit_2": ["Outside"], 
							"Outside-Exit_3": ["Outside"],
							"Outside-Exit_4": ["Outside"],
							"Outside-Exit_5": ["Outside"],
							"Outside-Exit_6": ["Outside"],
							"Stairs_1": ["M2", "M3"],
							"Stairs_2": ["M2", "M3"],
							"Stairs_3": ["M2", "M3"],
							"Elevator": ["M2", "M3"],
							"H-Building": ["H1"]

						}
					}
				}
			}
		}		


		// Step 3: Load GeoJSON buildings
		fetch('campus.geojson?ts=' + new Date().getTime())
			.then(response => response.json())
			.then(data => {
				console.log("GeoJSON loaded:", data); // <-- This checks if the file is loading
                
                // Log all building names and their center coordinates
                data.features.forEach(f => {
                    if (f.geometry.type === "Polygon" || f.geometry.type === "MultiPolygon") {
                        const layer = L.geoJSON(f);
                        const bounds = layer.getBounds();
                        console.log(
                            f.properties.name,
                            "center:",
                            bounds.getCenter()
                        );
                    }
                });



				L.geoJSON(data, {
					onEachFeature: function(feature, layer) {
						let buildingName = feature.properties.name || "Unknown Building";
						layer.bindPopup("<b>" + buildingName + "</b><br>Click for floor plans");

						layer.on('click', function() {

							let bounds = layer.getBounds();
							console.log(bounds);

							let corners = [
								L.latLng(bounds.getNorth(), bounds.getWest()),  // top-left
								L.latLng(bounds.getNorth(), bounds.getEast()),  // top-right
								L.latLng(bounds.getSouth(), bounds.getEast()),  // bottom-right
								L.latLng(bounds.getSouth(), bounds.getWest())   // bottom-left
							];

							//map.fitBounds(bounds);	
                            //let zoom = map.getBoundsZoom(bounds, true);
                            //map.setView(bounds.getCenter(), zoom);
							alert("Here you could load floor plans for " + buildingName);
							if (buildingName === "Building A") {
								let prePath = floorPlans[buildingName]["path"]

        						let svgPath = prePath + "/A1.svg?ts=" + new Date().getTime();


								fetch(svgPath)
									.then(r => r.text())
									.then(svgText => {
										const svgDoc = new DOMParser().parseFromString(svgText, 'image/svg+xml');
										const svgMap = svgDoc.documentElement; 
                                        //console.log([...svgMap.querySelectorAll('[id]')].map(el => el.id));
										

										//if (currentOverlay) map.removeLayer(currentOverlay); // remove old overlay
                        				newOverlay = L.svgOverlay(svgMap, corners, { interactive: true, opacity: 0.5 }).addTo(map);
									});
							} else if (buildingName === "Building M") {
								let prePath = floorPlans[buildingName]["path"]

        						let svgPath = prePath + "/M1.svg?ts=" + new Date().getTime();
								
								let rooms = floorPlans[buildingName]["objects"]["floor1"]["rooms"]                                

								fetch(svgPath)
									.then(r => r.text())
									.then(svgText => {
										const svgDoc = new DOMParser().parseFromString(svgText, 'image/svg+xml');
										const svgMap = svgDoc.documentElement; 
                                        //console.log([...svgMap.querySelectorAll('[id]')].map(el => el.id));
										

										//if (currentOverlay) map.removeLayer(currentOverlay); // remove old overlay
                        				currentOverlay = L.svgOverlay(svgMap, corners, { interactive: true, opacity: 0.5 }).addTo(map);


										// const hallway = svgMap.getElementById("Hallway-Route");
										// if (hallway) {
										// 	const d = hallway.getAttribute("d");
										// 	if (d) {
										// 		console.log("d HERE");
										// 		console.log(d);
										// 		const segments = d.split(/(?=[Mm])/);
												

										// 		const nodeCoords = [];
										// 		const movePoints = [];
										// 		segments.forEach(segment => {
										// 			const numbers = Array.from(segment.matchAll(/[-+]?[0-9]*\.?[0-9]+/g)).map(Number);
										// 			for (let i = 0; i < numbers.length; i += 2) {
										// 				const pt = {x: numbers[i], y: numbers[i + 1]};
										// 				nodeCoords.push(pt);

										// 				//if segment starts with M, append the first point into movePoints list
										// 				if (i === 0) movePoints.push(pt);
										// 			}
										// 		});
												
										// 		const latLngs = nodeCoords.map(pt => 
										// 			doorToLatLng({ getBBox: () => ({ x: pt.x, y: pt.y, width: 0, height: 0 }) }, svgMap, corners)
										// 		);

										// 		const moveLatLngs = movePoints.map(pt => 
										// 			doorToLatLng({ getBBox: () => ({ x: pt.x, y: pt.y, width: 0, height: 0 }) }, svgMap, corners)
										// 		);
												
										// 		// Highlight regular nodes
										// 		latLngs.forEach((latlng, index) => {
										// 			L.circleMarker(latlng, { radius: 4, color: "red", fillColor: "yellow", fillOpacity: 0.8 })
										// 				.bindPopup(`Node ${index}`)
										// 				.addTo(map);
										// 		});

										// 		// Highlight move-to nodes differently
										// 		moveLatLngs.forEach((latlng, index) => {
										// 			L.circleMarker(latlng, { radius: 6, color: "blue", fillColor: "cyan", fillOpacity: 0.8 })
										// 				.bindPopup(`Move Node ${index}`)
										// 				.addTo(map);
										// 		});

										// 	}
										// }
                                        
                                        

										Object.entries(rooms).forEach(([roomId, doorList]) => {
											const room = svgMap.getElementById(roomId);
											console.log(room);
											if (room) {
												room.style.pointerEvents = 'all';
												room.style.cursor = 'pointer';
												room.addEventListener('click', (e) => {
													// simple demo popup
													alert(`You clicked Room ${roomId} !`);
													svgMap.querySelectorAll('.highlighted-door').forEach(prevDoor =>{
														prevDoor.classList.remove('highlighted-door');
														prevDoor.style.stroke = '';
														prevDoor.style.strokeWidth = '';
													});


													//Highlight doors
													if (doorList.length > 0){
														doorList.forEach(doorId => {
															const door = svgMap.getElementById(doorId);
															if (door) {
																door.classList.add('highlighted-door');
																door.style.stroke = 'red';
																door.style.strokeWidth = '2px';
															} else {
																alert(`Door label for ${roomId} is not the same in SVG and code`);
															}
														});
                                                        // ðŸ§­ Step 2: Draw a simple path from start marker to door (temporary)
                                                        const firstDoor = svgMap.getElementById(doorList[0]);
														if (firstDoor) {
															const doorLatLng = doorToLatLng(firstDoor, svgMap, corners);

															// Remove previous line if it exists
															if (window.currentPathLine) map.removeLayer(window.currentPathLine);

															// Draw straight line
															window.currentPathLine = L.polyline(
																[startPoint, doorLatLng],
																{ color: "red", weight: 4, dashArray: "5, 5" }
															).addTo(map);

															// Optionally zoom to fit the line nicely
															map.fitBounds(L.latLngBounds([startPoint, doorLatLng]), { padding: [50, 50] });

														} else {
															console.warn(`Door not found for ${roomId}`);
														}

													} else {
														alert(`No doors currently exist for ${roomId}`);
													}
												});
											} else {
												console.warn(`Room ID ${roomId} not found`);
											}
										});
										//L.svgOverlay(svgMap, corners, {interactive: true, opacity: 0.5}).addTo(map);
									})
        							.catch(err => console.error("Error loading SVG:", err));
        						// add the SVG overlay on top of building
        						//currentOverlay = L.imageTransform(svgPath, corners, { opacity: 0.8 }).addTo(map);
                                // L.imageOverlay(svgPath, corners, { opacity: 0.8 }).addTo(map);
							} else { 
								alert("No floorplans available for " + buildingName); 
							} 
						});	
					},
					style: {
						color: "blue",
						weight: 2,
						fillOpacity: 0.2
					}
				}).addTo(map);
			})
			.catch(err => console.error("Error loading GeoJSON:", err));
    </script>
	
</body>
</html>
